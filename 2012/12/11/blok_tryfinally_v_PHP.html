<html>
<head lang="">
    <meta charset="utf-8" />
    <title ng-meta="page.title">Блок try/finally в PHP</title>
    <meta name="keywords" ng-meta="page.tags" value="['php','программинг']" content="php программинг " />
    <meta name="date" ng-meta="page.date" content="2012-12-11" />
    <meta http-equiv="Refresh" content="0;URL='/#!/2012/12/11/blok_tryfinally_v_PHP.html'" />
</head>
<body>
<h1>
    Блок try/finally в PHP <small><nobr ng-bind="page.date | asdate:locale.date_format" class="published">2012-12-11</nobr></small>
</h1>

<p>Несмотря на мою нелюбовь к PHP, время от времени приходится к нему возвращаться, испытывая при этом различные неудобства из-за отсутствия элементарных вещей.</p>

<p>С замыканиями в PHP, слава Б-гу, уже разобрались, а вот блоков <code>try/finally</code> до сих пор не видно (хотя вроде как <a href="http://habrahabr.ru/post/149314/">обещают</a> в 5.5, но до него дожить ещё надо).</p>

<p>Я не буду опускаться по обсуждения, нужен ли <code>finally</code>, это абсолютно пустые споры, которые ведут люди, никогда не писавшие ни на чём, кроме PHP, пытающиеся доказать превосходство своей платформы. Я же, следуя принципу «bottom-up» программирования и светлым заветам <a href="http://www.stevemcconnell.com/cc.htm">МакКоннела</a>, реализовал свою версию блока <code>try/finally</code>.</p>

<p>Что я сделал, так это смешал принцип <a href="http://ru.wikipedia.org/wiki/RAII">RAII</a> из С++ и использование замыканий из функционального программирования. Получился такой вот метр колючей проволоки:</p>

<div>
  <pre><code class="php">&lt;?php
class ensure {

    public function __invokeStatic() {
        $args = func_get_args();
        $try = array_shift($args);
        return new self($try, $args);
    }

    private $state;
    private $error;
    public function __construct($try, $args) {
        try {
            $this-&gt;state = call_user_func_array($try, $args);

        } catch (Exception $e) {
            $this-&gt;error = $e;
        }
    }

    private $errorError;
    public function except($error, $callback) {
        if ($this-&gt;error and is_a($this-&gt;error, $error)) {
            $error = $this-&gt;error;
            $this-&gt;error = null;

            try {
                $callback($error);
            } catch (Exception $e) {
                $this-&gt;errorError = $e;
            }
        }

        return $this;
    }

    public function finally($callback) {
        $callback($this-&gt;state);
        $this-&gt;finish();
        return $this;
    }

    public function finish() {
        $error = false;
        if ($this-&gt;error) {
            $error = $this-&gt;error;
            $this-&gt;error = null;
        } elseif ($this-&gt;errorError) {
            $error = $this-&gt;errorError;
            $this-&gt;errorError = null;
        }

        if ($error) {
            throw $error;
        }

        return $this;
    }

    public function __destruct() {
        $this-&gt;finish();
    }
}</code></pre>
</div>

<p>Что же мы получили в итоге? А получили мы фактически новую версию блока <code>try/catch/finally</code>, которую можно использовать вместо стандартного <code>try/catch</code>:</p>

<div>
  <pre><code class="php">&lt;?php
ensure(function () {
    $fh = fopen(&quot;logfile.txt&quot;, &quot;a&quot;);
    fwrite($fh, &quot;Log data\n&quot;);
    return $fh;
})
-&gt;except(&#39;Exception&#39;, function ($e) {
    echo &quot;Error happened: &quot; . $e-&gt;getMessage();
})
-&gt;finally(function ($fh) {
    fclose($fh);
});</code></pre>
</div>

<p>«Блок» <code>finally</code> будет выполнен всегда, в не зависимости от ошибок, произошедших в «блоке» <code>try</code>, «блоки» <code>catch</code> будут работать как обычно. Однако необработанные исключения, возникшие в блоках <code>try</code> и <code>catch</code>, никуда не потеряются и будут вызваны после выполнения <code>finally</code>.</p>

<p>Если же <code>finally</code> нет, то по идее нужно вызвать <code>finish()</code> в конце, но даже если программист забудет это сделать, то сработает принцип <strong>RAII</strong>, так что в худшем случае накопненные необработанные исключения выскочат в конце функции.</p>

<p>Кроме того с помощью этого же механизма можно передавать состояние обратки блока кода из одной функции в другую, но это уже совсем другая история.</p>

<disqus name="kstep" />



<p class="clearfix tags">
    <a href="/#!/tag/php" class="tag badge" rel="tag">php</a><a href="/#!/tag/программинг" class="tag badge" rel="tag">программинг</a>
</p>
</body></html>
