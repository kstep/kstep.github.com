<html>
<head lang="">
    <meta charset="utf-8" />
    <title ng-meta="page.title">Выборка случайной записи в MySQL и PostgreSQL</title>
    <meta name="keywords" ng-meta="page.tags" value="['базы данных','постгря','SQL','мускул']" content="базы данных постгря SQL мускул " />
    <meta name="date" ng-meta="page.date" content="2009-06-03" />
    <meta http-equiv="Refresh" content="0;URL='/#!/2009/06/03/vyborka_sluchajnoj_zapisi_v_mysql_i_postgresql.html'" />
</head>
<body>
<h1>
    Выборка случайной записи в MySQL и PostgreSQL <small><nobr ng-bind="page.date | asdate:locale.date_format" class="published">2009-06-03</nobr></small>
</h1>

<p>Довольно частая задача — выборка набора случайных записей из БД.</p>

<p>Если погуглить можно найти кучу различных способов.</p>

<p>Самый очевидный <code>SELECT * FROM table ORDER BY RAND();</code> не выдерживает никакой критики, так как на больших таблицах будет жутко тормозить по вполне очевидным причинам.</p>

<p>Другой вариант — вытащить число записей <code>COUNT(*)</code>-ом, взять рандомное число от 1 до этого числа и организовать <code>LIMIT &lt;рамндом&gt;, 1</code>, но этот способ не катит, если нужно несколько записей: тут либо несколько запросов подряд делать надо, либо делать их же, но <code>UNION</code>-ом.</p>

<p>В Гугле есть ещё несколько вариантов (попробуйте поискать сами, есть интересные для разных типов СУБД), но вариант, изобретённый в своё время мной, я там не нашёл, поэтому кладу его тут:</p>

<div>
  <pre><code class="sql">SELECT * FROM table WHERE RAND() &gt; 0.5 LIMIT 10;</code></pre>
</div>

<p>Его фишка в том, что он в реальности намного быстрее, чем о том говорит <code>EXPLAIN</code>, и вот почему: выборка прекращается очень рано за счёт <code>LIMIT</code>-а, так что вся таблица выбираться не будет. Сортировки нет, поэтому будет простой скан без файл-сортинга (как в случае с <code>ORDER BY RAND()</code>, который к тому же мускулу придётся вычислить <strong>для каждой</strong> записи), а <code>RAND()</code> будет посчитан только для немногих записей, которые мускул успеет пройти до полного формирования результата запроса. Полный скан у нас будет в любом случае, раз нет особо выборки с участием индексов, но избавление от сортировки и вычисления функции для каждой строки — огромный шаг вперёд!</p>

<p>У данного способа, однако, есть один недостаток: довольно низкое качество случайности выборки. По большому счёту этот запрос опирается на тезис о том, что если сортировка не задана, то мускул вернёт записи в неопределённом порядке, как попало, что я здесь принимаю за случайный порядок, а это на самом деле не совсем так: опыты показывают, что первыми возвращаются как правило последние изменённые записи (хотя я могу ошибаться, пусть гуру поправят), так что чем новее запись тем больше у неё шансов попасть в выборку. А записи ближе к центру и концу таблицы попадут в выборку с наименьшей вероятностью, стремящейся к нулю к последним записям. Это отчасти можно скомпенсировать оперируя числом, с которым сравнивается <code>RAND()</code> (в моём случае это 0.5): чем оно больше, тем «дальше» успеет пройти мускул до полного формирования нужной выборки.</p>

<p>В общем, если вам нужно быстро выбрать несколько случайных записей из огромной таблицы и вас устраивает качество рандома, которое даёт этот запрос, то можете его смело использовать :) Он до сих пор трудится на благо человечетсва на одном из сайтов, к которым я приложил руку :)</p>

<p>Кстати, впервые он был опробован на PostgreSQL-е, так что можете пользовать и на нём.</p>


<p class="clearfix tags">
    <a href="/#!/tag/базы данных" class="tag badge" rel="tag">базы данных</a><a href="/#!/tag/постгря" class="tag badge" rel="tag">постгря</a><a href="/#!/tag/SQL" class="tag badge" rel="tag">SQL</a><a href="/#!/tag/мускул" class="tag badge" rel="tag">мускул</a>
</p>
</body></html>
