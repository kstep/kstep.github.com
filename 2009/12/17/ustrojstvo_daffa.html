<html>
<head lang="">
    <meta charset="utf-8" />
    <title ng-meta="page.title">Устройство Даффа</title>
    <meta name="keywords" ng-meta="page.tags" value="[]" content="" />
    <meta name="date" ng-meta="page.date" content="2009-12-17" />
    <meta http-equiv="Refresh" content="0;URL='/#!/2009/12/17/ustrojstvo_daffa.html'" />
</head>
<body>
<h1>
    Устройство Даффа <small><nobr ng-bind="page.date | asdate:locale.date_format" class="published">2009-12-17</nobr></small>
</h1>

<p>Последнее время занимаюсь самосовершенствованием: пытаюсь постигнуть дао монад. Получается с переменным успехом: на интуитивом уровне вроде понял, но мне этого мало, хочу понять их устройство на более глубоком уровне, чтобы не просто их использовать, но и понимать, как они работают. А пока копался в доках на вики и прочих источниках, наткнулся на ссылку о «<a href="http://ru.wikipedia.org/wiki/%D0%A3%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%BE_%D0%94%D0%B0%D1%84%D1%84%D0%B0">Duff’s device</a>».</p>

<p>Википедию прочитать, думаю, под силу каждому, но цель этого поста скорее зафиксировать полученное знание и понимание концепции мной самим, чтобы потом не забыть =)</p>

<p>Если кратко: устройство Даффа — это обобщение оптимизации циклов путём их развёртки. Проблема развёртки цикла с неизвестным числом повторов n в том, что при заданной глубине развёртки m существует n mod m «остаточных» итераций, которые надо обработать как особый случай. Дафф нашёл очень <a href="http://www.lysator.liu.se/c/duffs-device.html">элегантное решение</a> этой задачи на C:</p>

<div>
  <pre><code class="c">send(to, from, count)
register short *to, *from;
register count;
{
    register n = (count + 7) / 8;
    switch (count % 8) {
    case 0: do { *to = *from++;
    case 7:      *to = *from++;
    case 6:      *to = *from++;
    case 5:      *to = *from++;
    case 4:      *to = *from++;
    case 3:      *to = *from++;
    case 2:      *to = *from++;
    case 1:      *to = *from++;
               } while (--n &gt; 0);
    }
}</code></pre>
</div>

<p>Как это работает: цикл из count повторов разворачивается на n равных кусков по 8 операций в каждом, а остаток операций в n mod 8 штук выполняется через switch: при первой проходе мы попадаем на один из case’ов в зависимости от этого остатка и сразу выполняем нужное остаточное число операций, а потом цикл while() работает своим обычным образом, пропуская все куски, на которые разбит исходный цикл.</p>

<p>За подробностями, почему так сделано и почему *to не инкрементируется — см. ссылки. Если кратко: to это не просто ссылка на адрес в памяти, а ссылка на адрес в IO-памяти, а цель всего кода — передать устройству с портом ввода-вывода по адресу to набора из count команд из памяти начиная с адреса from.</p>


<p class="clearfix tags">
    
</p>
</body></html>
